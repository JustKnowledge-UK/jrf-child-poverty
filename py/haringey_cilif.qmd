---
title: "Untitled"
format: html
---

```{python}
import pandas as pd
import requests
from bs4 import BeautifulSoup
import re
import geopandas as gpd
from shapely.geometry import Point
import matplotlib.pyplot as plt
import matplotlib as mpl
import contextily as cx
from adjustText import adjust_text
import configparser
import psycopg2
import os
import pickle
import numpy as np
from sklearn.neighbors import BallTree, radius_neighbors_graph
from scipy.spatial import cKDTree
import janitor

config = configparser.ConfigParser()
config.read(os.path.join('..', 'db_config.ini'))

db_params = dict(config['postgresql'])
```


```{python}
with psycopg2.connect(**db_params) as con:
    query = '''SELECT *
                FROM east_coast_mainline_geometry
                '''

    trainline = gpd.read_postgis(query, con = con, geom_col='geometry')

    query2 = '''SELECT lad21nm, geometry 
                FROM lad21_boundaries 
                WHERE lad21nm = 'Haringey'
            '''
    haringey_gpd = gpd.read_postgis(query2, con = con, geom_col='geometry')

    
    query3 = '''SELECT *
                FROM railway_track_locations
                '''
            
    all_trainline = gpd.read_postgis(query3, con = con, geom_col='geometry')

    lads = ['Haringey','Enfield','Waltham Forest']
    formatted_list = ', '.join([f"'{lad}'" for lad in lads])
    query4 = f'''
            SELECT foo.* 
            FROM msoa21_boundaries AS foo
            RIGHT JOIN (
                SELECT DISTINCT msoa21cd
                FROM pcode_census21_lookup 
                WHERE ladnm IN ({formatted_list})
            ) AS loo
            ON foo.msoa21cd = loo.msoa21cd

             '''
    msoa_gdf = gpd.read_postgis(con=con, sql=query4, geom_col='geometry')

    query = '''
            SELECT DISTINCT msoa21cd 
            FROM pcode_census21_lookup
            WHERE ladnm = 'Haringey'
            '''
    haringey_msoas = pd.read_sql(con=con, sql=query)
                
```


Strange that the rail isn't perfectly aligned. Think this is as close as I'll get for now

Next add in CILIF data

```{python}
cilif_data = pd.read_csv(os.path.join('..','data','e&w_u16_low_income_families_msoa_2022-23.csv'))

cilif_data = cilif_data.rename(
    columns = {
        'msoa': 'msoa21nm',
        'mnemonic':'msoa21cd',
        'u16_percent_low_income_families':'percentage'
    }
)

cols_to_keep = ['msoa21nm','msoa21cd', 'percentage']

cilif_data = cilif_data[cols_to_keep]
cilif_gdf = msoa_gdf.merge(cilif_data, how='left', on='msoa21cd')

# Clip ECM geometries to Haringey
ecm = trainline.loc[trainline['track_names']=='East Coast Mainline']
ecm = ecm.to_crs(haringey_gpd.crs)
ecm_clipped = gpd.clip(ecm, haringey_gpd)
# all_trainline.crs = haringey_gpd.crs

```

```{python}
fig, ax = plt.subplots(figsize=[8,8])

cilif_gdf.plot(ax=ax,column='percentage', legend=True, legend_kwds=dict({'label': 'Percentage of low income families'}), alpha=0.7)
ecm_clipped.plot(ax=ax, color='red')
cx.add_basemap(ax, crs=cilif_gdf.crs, source=cx.providers.OpenStreetMap.Mapnik)
ax.set_axis_off();
```

```{python}
from mpl_toolkits.axes_grid1 import make_axes_locatable

# Get northumberland park centroid
np = cilif_gdf.loc[cilif_gdf['msoa21cd']=='E02000398']
np['centroid'] = np.geometry.centroid

# get muswell hill north and south and dissovle into one, then get centroid
mh = cilif_gdf.loc[(cilif_gdf['msoa21cd']=='E02000417') | (cilif_gdf['msoa21cd']=='E02000410')]
mh = mh.dissolve()
mh['centroid'] = mh.geometry.centroid

from shapely.geometry import Point
# Create Point in WGS84 (lon, lat)
ally_point = Point(-0.131911, 51.594341)
ally_pally = gpd.GeoDataFrame(geometry=[ally_point], crs="EPSG:4326")

# Reproject ally_pally to the same CRS as cilif_gdf
ally_pally = ally_pally.to_crs(cilif_gdf.crs)

fig, ax = plt.subplots(figsize=[8, 8])

# Plot the main layers
cilif_gdf.plot(ax=ax, column='percentage', legend=False, alpha=0.5, edgecolor='black',linewidth=.5)
ecm_clipped.plot(ax=ax, color='red')
cx.add_basemap(ax, crs=cilif_gdf.crs, source=cx.providers.OpenStreetMap.Mapnik)
ax.set_axis_off()

# Create a separate legend axis

divider = make_axes_locatable(ax)
cax = divider.append_axes("right", size="5%", pad=0.1)

# Create a dummy mappable for the colorbar
norm = mpl.colors.Normalize(vmin=cilif_gdf['percentage'].min(), vmax=cilif_gdf['percentage'].max())
cmap = plt.cm.viridis
sm = plt.cm.ScalarMappable(cmap=cmap, norm=norm)
sm._A = []

# Draw the colorbar in the new axes (same height)
cbar = fig.colorbar(sm, cax=cax)
cbar.set_label("Percentage of children in low income families")

ax.text(
    np['centroid'].x,
    np['centroid'].y,
    s='Northumberland Park',
    ha='center',
    fontsize=8
);

ax.text(
    mh['centroid'].x,
    mh['centroid'].y,
    s='Muswell Hill',
    ha='center',
    fontsize=8,
    color='white'
);

ally_pally.plot(ax=ax, marker='o',color='red', markersize=5)

x_range = ax.get_xlim()[1] - ax.get_xlim()[0]
nudge_x = x_range * .01
y_range = ax.get_ylim()[1] - ax.get_ylim()[0]
nudge_y = y_range * .01

ax.text(
    ally_pally.geometry.x - nudge_x,
    ally_pally.geometry.y + nudge_y,
    s='Alexandra\nPalace',
    ha='left',
    fontsize=8,
    color='white'

);

ax.text(ax.get_xlim()[1], ax.get_ylim()[0]*.999, s='Red line indicates approximate position of the East Coast Main Line Railway', ha='right', size=8);

plt.tight_layout()
fig.savefig(os.path.join('..','outputs','cilif_haringey.png'), dpi=600)
```
```{python}

# all_rail_clipped = gpd.clip(all_trainline, haringey_gpd)

fig, ax = plt.subplots(1,1, figsize=[8,8])

haringey_gpd.boundary.plot(ax=ax)
# ecm_clipped.plot(ax=ax, color = 'red')
ecm_clipped.plot(ax=ax, color = 'red')
cx.add_basemap(ax, crs = haringey_gpd.crs, source=cx.providers.OpenStreetMap.Mapnik)
```


# CILIF over time

First get the non-haringey areas of interest

```{python}
np_gdf = msoa_gdf.loc[msoa_gdf['msoa21cd']=='E02000398']
test = msoa_gdf.touches(np_gdf)

target_geom = np_gdf.geometry.iloc[0]

# Spatial join: find all geometries that touch it
touching = gpd.sjoin(msoa_gdf, np_gdf, predicate='touches')

# Remove the target area from results (optional)
touching = touching[touching['msoa21cd_left'] != 'E02000398']

areas_to_add = touching['msoa21cd_left'].unique().tolist()

```

note need pop ests by age too


```{python}
cilif_london = pd.read_csv(os.path.join('..','data','cilif_msoa_london.csv'), skiprows=8, skipfooter=14)

cilif_london = cilif_london.loc[:, ~cilif_london.columns.str.contains("Annotations", na=False)]

# Step 2: Rename the first two columns for clarity
cilif_london.rename(columns={cilif_london.columns[0]: "Area Code", cilif_london.columns[1]: "Age Band"}, inplace=True)

cilif_london["Area Code"] = cilif_london["Area Code"].fillna(method='ffill')
cilif_london = cilif_london[cilif_london["Age Band"] == "Total"]

cilif_london = cilif_london.drop(columns=['Age Band', 'Unnamed: 22'])

# Step 5: Reshape the data into long format
cilif_london_long = cilif_london.melt(id_vars="Area Code", 
                                      var_name="Year", 
                                      value_name="Value")

cilif_london_long = janitor.clean_names(cilif_london_long)

cilif_london_long['value'] = cilif_london_long['value'].astype(int)


```


```{python}

path = os.path.join('..', 'data', 'pop_msoa_age.csv')
pop_ests = pd.read_csv(path, skiprows=6)

pop_ests = janitor.clean_names(pop_ests)

pop_ests[['msoa21cd', 'msoa21nm']] = pop_ests['2021_super_output_area_middle_layer'].str.split(' : ', expand=True)

pop_ests = pop_ests.drop(columns='2021_super_output_area_middle_layer')


pop_ests = pop_ests.melt(
    id_vars=['msoa21cd','msoa21nm'],
    var_name='age',
    value_name='population'

)

pop_ests['age'] = pop_ests['age'].str.split('_').str[1]
pop_ests['age_numeric'] = pd.to_numeric(pop_ests['age'], errors='coerce')

pop_ests_u15 = pop_ests.loc[pop_ests['age_numeric'] <= 15]

pop_ests_u15 = pop_ests_u15.groupby(['msoa21cd','msoa21nm'])['population'].sum().reset_index()


```


```{python}
cilif_london_long = cilif_london_long.merge(pop_ests_u15, how='left', left_on='area_code',right_on='msoa21cd')

cilif_london_long['percentage'] = cilif_london_long['value'].div(cilif_london_long['population']).mul(100)

# Assign reversed decile ranks: 1 = highest value, 10 = lowest value
cilif_london_long['decile'] = cilif_london_long.groupby('year')['percentage']\
    .transform(lambda x: pd.qcut(-x, q=10, labels=False, duplicates='drop') + 1)
```


```{python}
msoas_list = haringey_msoas['msoa21cd'].tolist() + areas_to_add
diff_df = cilif_london_long.loc[cilif_london_long['msoa21cd'].isin(msoas_list)]

diff_df['start_year'] = diff_df['year'].str.split('/').str[0].astype(int)

# Find oldest and most recent years
oldest_year = diff_df['start_year'].min()
most_recent_year = diff_df['start_year'].max()

# Filter for only the two years
diff_df_filtered = diff_df[diff_df['start_year'].isin([oldest_year, most_recent_year])]

# Pivot so we have decile values side by side
pivot_df = diff_df_filtered.pivot(index='msoa21cd', columns='start_year', values='decile')
# Rename columns for clarity
pivot_df = pivot_df.rename(columns={oldest_year: f'decile_{oldest_year}', most_recent_year: f'decile_{most_recent_year}'})

# Calculate the difference
pivot_df['decile_diff'] = pivot_df['decile_2023'] - pivot_df['decile_2014']
diff_gdf = msoa_gdf.merge(pivot_df, how='right',on='msoa21cd')

```

# in 2023

```{python}
fig, ax = plt.subplots(figsize=[8,8])

diff_gdf.plot(ax=ax, column='decile_2023', legend=False, alpha=0.7, edgecolor='black',linewidth=0.4)

divider = make_axes_locatable(ax)
cax = divider.append_axes("right", size="5%", pad=0.1)

# Create a dummy mappable for the colorbar
norm = mpl.colors.Normalize(vmin=diff_gdf['decile_2023'].min(), vmax=diff_gdf['decile_2023'].max())
cmap = plt.cm.viridis
sm = plt.cm.ScalarMappable(cmap=cmap, norm=norm)
sm._A = []

# Draw the colorbar in the new axes (same height)
cbar = fig.colorbar(sm, cax=cax)
cbar.set_label("Decile change")

ax.set_axis_off()
cx.add_basemap(ax, crs=diff_gdf.crs, source=cx.providers.OpenStreetMap.Mapnik)
fig.suptitle(y=.73, t='Children in low income families: Decile change from 2014 to 2023')
np = diff_gdf.loc[diff_gdf['msoa21cd'] == 'E02000398']
np['centroid'] = np.geometry.centroid
x, y = np['centroid'].iloc[0].x, np['centroid'].iloc[0].y
np_decile_change = np['decile_2023'].astype(int).iloc[0]
ax.text(x=x, y=y, s=f'NP\nDecile change = {np_decile_change}', ha='center', size=8)
```


```{python}
fig, ax = plt.subplots(figsize=[8,8])

diff_gdf.plot(ax=ax, column='decile_diff', legend=False, alpha=0.7, edgecolor='black',linewidth=0.4)

divider = make_axes_locatable(ax)
cax = divider.append_axes("right", size="5%", pad=0.1)

# Create a dummy mappable for the colorbar
norm = mpl.colors.Normalize(vmin=diff_gdf['decile_diff'].min(), vmax=diff_gdf['decile_diff'].max())
cmap = plt.cm.viridis
sm = plt.cm.ScalarMappable(cmap=cmap, norm=norm)
sm._A = []

# Draw the colorbar in the new axes (same height)
cbar = fig.colorbar(sm, cax=cax)
cbar.set_label("Decile change")

ax.set_axis_off()
cx.add_basemap(ax, crs=diff_gdf.crs, source=cx.providers.OpenStreetMap.Mapnik)
fig.suptitle(y=.73, t='Children in low income families: Decile change from 2014 to 2023')
np = diff_gdf.loc[diff_gdf['msoa21cd'] == 'E02000398']
np['centroid'] = np.geometry.centroid
x, y = np['centroid'].iloc[0].x, np['centroid'].iloc[0].y
np_decile_change = np['decile_diff'].astype(int).iloc[0]
ax.text(x=x, y=y, s=f'NP\nDecile change = {np_decile_change}', ha='center', size=8)

fig.savefig(os.path.join('..','outputs','cilif_haringey_change_2014-23.png'), dpi=600)
```


```{python}
import matplotlib.pyplot as plt
import matplotlib as mpl
from matplotlib.colors import TwoSlopeNorm, LinearSegmentedColormap
from mpl_toolkits.axes_grid1 import make_axes_locatable
import contextily as cx

# Create a custom diverging colormap: red (low), grey (neutral), green (high)
cmap = LinearSegmentedColormap.from_list(
    'custom_diverging',
    ['darkred', 'lightgrey', 'darkgreen'],
    N=256
)

# Normalize around 0
norm = TwoSlopeNorm(
    vmin=diff_gdf['decile_diff'].min(),
    vcenter=0,
    vmax=diff_gdf['decile_diff'].max()
)

# Plotting
fig, ax = plt.subplots(figsize=[8,8])

diff_gdf.plot(
    ax=ax,
    column='decile_diff',
    cmap=cmap,
    norm=norm,
    legend=False,
    alpha=0.7,
    edgecolor='black',
    linewidth=0.4
)

divider = make_axes_locatable(ax)
cax = divider.append_axes("right", size="5%", pad=0.1)

# Dummy mappable for colorbar
sm = plt.cm.ScalarMappable(cmap=cmap, norm=norm)
sm._A = []

cbar = fig.colorbar(sm, cax=cax)
cbar.set_label("Decile change")

# Map decoration
ax.set_axis_off()
cx.add_basemap(ax, crs=diff_gdf.crs, source=cx.providers.OpenStreetMap.Mapnik)

# Title
fig.suptitle(y=.73, t='Children in low income families: Decile change from 2014 to 2023')


# Add NP label
np = diff_gdf.loc[diff_gdf['msoa21cd'] == 'E02000398']
np['centroid'] = np.geometry.centroid
x, y = np['centroid'].iloc[0].x, np['centroid'].iloc[0].y
np_decile_change = np['decile_diff'].astype(int).iloc[0]
ax.text(x=x, y=y, s=f'NP\nDecile change: {np_decile_change}', ha='center', size=8)


fig.savefig(os.path.join('..','outputs','cilif_haringey_change_2014-23.png'), dpi=600)
```